# CourseWork
Considering in more detail the possibilities of Java 8, hibernate, spring boot

---
###Состоит из 2 логических блоков:
### Java Core   
   [1] Основы. Примитивные типы<br>
   - Task1 - Написать программу, которая находит минимум из двух чисел, введенных с командной строки<br>

   [2] Основы. Конструкторы, классы обертки<br>
   - Task2 - Реализовать класс, описывающий вектор (в трёхмерном пространстве)<br>

   [3] Основы. String и пр. Object<br>
   - Task3 - Написать консольный калькулятор, умеющий производить базовые вычисления c последовательным вводом цифр и операторов.
     <br>

   [4] Парадигмы ООП Часть <br>
   - Task4 - Предоставить реализацию стека и очереди (на массивах Object) с основными операциями:
     **Очередь:** Enqueue(), Dequeue(), isEmpty(), Top(); <br>
       **Стек**: Push(), Pop(), isEmpty(), Top(); <br>
    a) Добавить тесты (junit) на работоспособность очереди,стека, при удалении из пустой очереди, добавлении и т.д.
<br>
    б) javaDoc <br><br>

   - Task5 - Придумать свой пример использования абстрактной фабрики и реализовать ее (шаблоны: фабрика и абстрактная фабрика)

   [5] Вариации внутренних классов + Исключения<br>
   [6] Коллекции<br>
   - Task 6 -  Сделать как минимум 3 метода для поиска дубликатов. Написать тесты. Для долгих методов использовать assertTimeoutPreemptively<br>

   [7] Generics<br>
   - Task 7 -  Необходимо написать класс ArrayIterator который умеет работать с массивами T[][]. Тесты <br>

   [8] Сериализация/Десериализация + Загрузчики<br>
   [9] Сборка мусора<br>
   [10] Лямбды + Stream API + VAR<br>
   - Task 8 - Написать метод, который на вход принимает текст. Метод должен посчитать частоту появления слов, и отдать массив из 10 слов которые чаще всего встретились в тексте. Если в тексте меньше 10 уникальных слов, то метод отдаст сколько есть. Если в тексте некоторые слова имеют одинаковую частоту, то отдаем их в лексикографическом порядке.
     Слово это любая непрерывная последовательность символов. Даже с символами точка, запятая.

   [11] Optional<br>
   [12] Java Reflection API<br>
   [13] Annotations<br>
   - Task9 - Создать класс, который может выполнять тесты (рукописный junit), в качестве тестов выступают классы с наборами методов над которыми есть аннотация @DoTest - собственная аннотация.).<br>
     Из «класса-теста» вначале должен быть запущен метод с аннотацией @DoBeforeAll если такой имеется, далее запущены методы с аннотациями @DoTest, а по завершению всех тестов – метод с аннотацией @DoAfterAll.<br>
     Если что то не так то кидаем исключение.<br>
     Тесты через junit<br>

   [14] Сокеты, потоки данных<br>
   [15] Многопоточность. Основы<br>
   - Task 10 - Задача продемонстрировать каждое из возможных состояний потока. Добавление мьютекса если необходимо.<br>
   
[16] Java.util.concurrent<br>
   - Task 11 - Есть банк. В нем N счетов и M клиентов.<br>
     Клиент может переводить деньги с одного счёта на другой. <br>
Необходимо создать демона наблюдателя, который будет следить, за статусом, что денежная масса в системе постоянна, нет утечек. Денежный пул создаётся при запуске программы, он фиксирован и указывается через проперти файл.

[17] Clean Code<br>

---
### Java EE
   [19] Базы данных<br>
   [20] Средства сборки<br>
   [21] Hibernate<br>
   [22] Java EE + Spring Framework<br>
   [23] Sonar<br>
   [24] Jasypt<br>